# Introduction

At the end of this chapter, you will have:
* Created the project directory
* Installed Composer and initialised a new project
* Installed your first dependency

## Project directory structure
Creating the project directory structure is a trivial yet important task. The directory structure lays the foundation on how the code is organized within your application. There are no golden rules here and it all comes down to personal taste and what the project is about. If you are already working on a legacy application, it is strongly suggested to use the existing structure. This could save you from the additional trouble to adjust the existing configuration. In the next section, we will study how the Composer can be configured to autoload classes, according to your directory structure.

The following structure is more than sufficient, in most of the cases. This is common among the modern PHP frameworks like Laravel and Symfony, but please note that the actual directory name may vary from framework to framework. 

* **Application**: your core application code like the application controllers and database models.
* **Executables**: the executable files (command line).
* **Resources**: your application configuration, templates and translation files.
* **Public assets**: the web root directory. It contains your public entry-points along with any other public assets. Usually, there is only one file like app.php or index.php which bootstraps the whole application.
* **Tests**: the automatic tests for your application.
* **Other**: all the files being generated by the application, like cache files and log files among others.

Here is the structure that we will use in the following examples
* `app/` Application
* `bin/`
* `resources/` Resources
* `public/` Public assets
* `tests/` Tests
* `var/` Other

*Project setup*
The Composer is a great dependency manager for PHP. You can define the libraries you depends on and check which versions can be installed. It is also possible to share the dependencies with your colleagues. All the dependencies along with the project information are being stored in `composer.json` file.

Using Composer in legacy applications is a crutial upgrade. It changes the way third-party libraries are being installed and lays a strong foundation for upcoming changes. It may seems cumbersome to enable Composer in a legacy application but it is totally worth it.

This section assumes that you have already installed the Composer. If you don't, you can follow the instructions at https://getcomposer.org/doc/00-intro.md . At the time of writing, the latest version is 1.6.5.

As a first step, we need to create the `composer.json` file for our new project. While it is possible to create the file manually, there is no reason to. Executing the following command, it will ask you for the most important project details (title, description, authros etc) and then build the `composer.json` file.

```
$ composer init
```

Here is a sample of the questions currently prompted by Composer:

```
This command will guide you through creating your composer.json config.

Package name (<vendor>/<name>): softius/no-framework-chapter-1
Description []: Build your own PHP Application - Chapter 1
```

Once the `composer.json` has been created, we need to declare our directory structure, so that Composer can autoload our classes. The following must be appended in `composer.json` file. Mind the `MyApp` which indicates the application namespace.

``` json
    "autoload": {
        "psr-4": {
            "MyApp\\": "app/"
        }
    },
    "autoload-dev": {
        "psr-4": {
            "MyApp\\Tests\\": "tests/"
        }
    }
```

**Our first dependency**
Installing a new dependency is fairly easy and straightforward. Below we declare PHPUnit as a dependency in the development environment (mind the `--dev` flag). Dependencies can be found in Packagist.org and then can be installed, as follows:

```
$ composer require phpunit/phpunit --dev
```